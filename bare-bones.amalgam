#if 0
#/*
# ______                 ______
# | ___ \                | ___ \
# | |_/ / __ _ _ __ ___  | |_/ / ___  _ __   ___  ___ 
# | ___ \/ _` | '__/ _ \ | ___ \/ _ \| '_ \ / _ \/ __|
# | |_/ / (_| | | |  __/ | |_/ / (_) | | | |  __/\__ \
# \____/ \__,_|_|  \___| \____/ \___/|_| |_|\___||___/
#
# No include, no linking minimalistic and hacky single file CLI game.
#
# Taken steps:
# - Removed last 6 zeroed bytes of ehdr, for some reason elf loader can extend it automatically.
# - No dynamic memory mapping, .bss is used instead, which leaves mapping with zeroing to loader.
# - Assume success, take approaches that least susceptible to failing.
# - Use the fact that process termination clears the state, such as opened files.
# - Assume cwd has executable in it.
# - Zeroing of p_paddr is compressing freindly and shaves a few bytes, same with p_align for non-load commands.
# - ELF alignment restrictions are ignored.
#
# Currently only targets amd64-linux-gnu.
#
# To compile and run just execute this file.
#
# Used resources
# --------------
# - ELF madness:
# https://man7.org/linux/man-pages/man5/elf.5.html
# https://refspecs.linuxbase.org/elf/gabi4+/ch5.dynamic.html
# https://www.muppetlabs.com/~breadbox/software/tiny/teensy.html
# https://binaryresearch.github.io/2019/09/17/Analyzing-ELF-Binaries-with-Malformed-Headers-Part-1-Emulating-Tiny-Programs.html
# https://ioactive.com/striking-back-gdb-and-ida-debuggers-through-malformed-elf-executables/
# http://shell-storm.org/blog/Linux-process-execution-and-the-useless-ELF-header-fields/
# https://raw.githubusercontent.com/radareorg/r2con2019/master/talks/elf_crafting/ELF_Crafting_ulexec.pdf
# https://board.flatassembler.net/topic.php?t=7490
#
# - Size related GCC/LD options:
# http://ptspts.blogspot.com/2013/12/how-to-make-smaller-c-and-c-binaries.html
#
# - Neat demoscene wiki page:
# https://in4k.github.io/wiki/linux
#
# - vt340 manual for sixel graphics programming:
# https://www.vt100.net/docs/vt3xx-gp/chapter14.html
# https://www.vt100.net/docs/vt3xx-gp/chapter13.html
#
# - Audio is achieved by OSS ioctl calls via PulseAudio wrapper:
# https://manpages.ubuntu.com/manpages/focal/man1/padsp.1.html
# http://manuals.opensound.com/developer/DSP.html
#
#*/

set -e
cat << ELF_HEADER_SOURCE > ./elf.as
elfoff = 0x08048000
vaddr = 0x08048000
.text
ehdrstart:
  .byte      0x7F                       # e_ident
  .ascii     "ELF"
  .byte      2, 1, 1
.global dynopen
dynopen:
ninezeroes:
  .skip      9, 0
  .word      2                          # e_type
  .word      62                         # e_machine
  .long      1                          # e_version
  .quad      entry                      # e_entry
  .quad      phdrstart - elfoff         # e_phoff
  .quad      0                          # e_shoff
  .long      0                          # e_flags
  .word      ehdrsize                   # e_ehsize
  .word      56                         # e_phentsize
  .word      3                          # e_phnum
#Could be removed, but GDB will not happy about it:
  .skip      6, 0
ehdrsize = . - ehdrstart

phdrstart:
#PT_INTERP
  .long      3                          # p_type
  .long      7                          # p_flags
  .quad      interp - elfoff            # p_offset
  .quad      interp                     # p_vaddr
  .quad      0                          # p_paddr
  .quad      interpsz                   # p_filesz
  .quad      interpsz                   # p_memsz
  .quad      0x0000                     # p_align

#PT_DYNAMIC
  .long      2                          # p_type
  .long      7                          # p_flags
  .quad      dynamic - elfoff           # p_offset
  .quad      dynamic                    # p_vaddr
  .quad      0                          # p_paddr
  .quad      dynamicsz                  # p_filesz
  .quad      dynamicsz                  # p_memsz
  .quad      0x0000                     # p_align

#PT_LOAD
  .long      1                          # p_type
  .long      7                          # p_flags
  .quad      0                          # p_offset
  .quad      vaddr                      # p_vaddr
  .quad      0                          # p_paddr
  .quad      filesz                     # p_filesz
  .quad      memsz                      # p_memsz
  .quad      0x0000                     # p_align

interp:
  .asciz "/lib64/ld-linux-x86-64.so.2"
interpsz = . - interp

dynamic:
#Fake hash:
  .quad     4,  symtab                # DT_HASH
  .quad     5,  strtab                # DT_STRTAB
  .quad     6,  symtab                # DT_SYMTAB
  .quad     10, 1                     # DT_STRSZ
  .quad     11, 24                    # DT_SYMENT
  .quad     7,  rela                  # DT_RELA
  .quad     8,  relasz                # DT_RELASZ
  .quad     9,  24                    # DT_RELAENT
  .quad     0,  0
dynamicsz = . - dynamic

#todo : Overlap zero byte with null entry of dynamic.
strtab:
  .byte     0
  .asciz    "open"

#todo : Overlap first zero byte with null terminator of "open".
#todo : Reuse in somewhere else.
symtab:
  .skip     24, 0
  .long     1               # strtab index
  .byte     2 << 4 + 2, 0   # STB_GLOBAL, STT_FUNC, STV_DEFAULT
  .word     0               # No section header info
  .quad     0, 0

#todo : Can we use rel instead ?
rela:
  .quad     dynopen     # r_offset
  .quad     1 << 32 + 1 # r_info
  .quad     0           # r_addend
relasz = . - rela
ELF_HEADER_SOURCE

#todo : Use / tmp /
cat << LINKER_SCRIPT_SOURCE > ./ld.scr
SECTIONS {
  . = 0x08048000;
  filestart = .;

  .elf : { ./elf.o (.text) }

  /* todo: Would 1 alignment break C assumptions? */
  .text ALIGN(0x1) : SUBALIGN(0x1) { *(.text) *(.rodata) }
  .data ALIGN(0x1) : SUBALIGN(0x1) { *(.data) }
  filesz = . - filestart;

  .bss : { *(.bss) }
  memsz = . - filestart;

  /DISCARD/ : {
    *(.note.*)
    *(.gnu*)
    *(.gcc*)
    *(.comment)
    *(.eh_frame*)
  }
}
OUTPUT_FORMAT(binary)
LINKER_SCRIPT_SOURCE

as --64 -o elf.o elf.as
cc -c -o ./bare-bones.o -x c -std=gnu89 $0 -nostdlib -Os \
  -DBARE_BONES -Wall -Wextra -Wpedantic -Werror -march=core2 \
  -fno-stack-protector -fomit-frame-pointer -mpreferred-stack-boundary=3 \
  -falign-functions=1 -falign-jumps=1 -falign-loops=1 -fno-unwind-tables \
  -fno-asynchronous-unwind-tables -fmerge-all-constants -fno-ident -fno-stack-check \
  -mno-stack-arg-probe -Qn -fno-PIC -fno-PIE -static -fno-plt \
  -ffunction-sections -fdata-sections
ld -m elf_x86_64 -T ld.scr -s -o bare-bones ./elf.o ./bare-bones.o \
  --build-id=none -z norelro -z noseparate-code --no-eh-frame-hdr \
  --no-ld-generated-unwind-info --hash-style=sysv \
  -z nodynamic-undefined-weak --gc-sections
set +e
if [ -x $(command -v upx) ]; then
  upx ./bare-bones -q --best --ultra-brute
fi
./bare-bones
exit;
#endif

#ifdef BARE_BONES

#define EXELTR "./bare-bones"
#define NULLPTR (void *)0
#define LENGTHOF(p_arr) (sizeof(p_arr) / sizeof(*p_arr))

#ifdef DEBUG
/* todo: int3 */
#define ASSERT(p_expr)                                                         \
  {                                                                            \
    if (!(p_expr)) {                                                           \
      SYS_WRITE_LITERAL(FD_STDOUT, "assert failed for: " #p_expr "\n");        \
      SYS_EXIT(-1);                                                            \
    }                                                                          \
  }
#else
#define ASSERT(p_expr) (p_expr) ? (void)0 : __builtin_unreachable()
#endif /* ifdef DEBUG */

/* https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86_64-64_bit
 */

/* todo: Generic SYS_CALL macro?
 * https://github.com/Jorengarenar/CMObALL/blob/master/cmoball.h
 */

/* https://man7.org/linux/man-pages/man2/exit.2.html */
#define SYS_EXIT(p_return_code)                                                \
  asm volatile("syscall" : : "a"(60), "D"(p_return_code) : "rcx", "r11")

/* https://man7.org/linux/man-pages/man2/write.2.html
 * todo: "m" is only valid for GCC, not Clang.
 * https://stackoverflow.com/questions/56432259/how-can-i-indicate-that-the-memory-pointed-to-by-an-inline-asm-argument-may-be
 */
#define SYS_WRITE(p_fd, p_msg, p_msg_len)                                      \
  asm volatile("syscall"                                                       \
               : "=a"(sys_result)                                              \
               : "a"(1), "D"(p_fd), "S"(p_msg), "d"(p_msg_len)                 \
               : "rcx", "r11", "memory")

#define FD_STDIN 0
#define FD_STDOUT 1

#define SYS_WRITE_LITERAL(p_fd, p_msg) SYS_WRITE(p_fd, p_msg, sizeof(p_msg) - 1)

/* https://man7.org/linux/man-pages/man2/open.2.html */
#define SYS_OPEN(p_fd_out, p_path, p_flags)                                    \
  asm volatile("syscall"                                                       \
               : "=a"(p_fd_out)                                                \
               : "a"(2), "D"(p_path), "S"(p_flags), "d"(0666),                 \
                 "m"(*(const char(*)[sizeof(p_path)])(p_path))                 \
               : "rcx", "r11")

#define O_RDONLY 0
#define O_WRONLY 1

/* https://man7.org/linux/man-pages/man2/execve.2.html
 * note: Reuses NULL at the end of wrapping_args for envp
 */
#define SYS_EXECVE(p_path, p_argv, p_envp)                                     \
  asm volatile("syscall"                                                       \
               : "=a"(sys_result)                                              \
               : "a"(59), "D"(p_path), "S"(p_argv), "d"(p_envp)                \
               : "rcx", "r11", "memory")

/* https://man7.org/linux/man-pages/man2/vfork.2.html */
#define SYS_VFORK(p_result_out)                                                \
  asm volatile("syscall" : "=a"(p_result_out) : "a"(58) : "rcx", "r11");

#define ASCII_ESCAPE "\x1b"
#define SIXEL_MODE_START ASCII_ESCAPE "P7q"
#define SIXEL_MODE_END ASCII_ESCAPE "\\"

/*
static int int_to_buffer(int in, char *out) {
  int r = 0;
  if (in < 0) {
    *(out++) = '-';
    do {
      *(out++) = '0' + -(in % 10);
      in /= 10;
    } while (r++, in != 0);
    return r + 1;
  }

  do {
    *(out++) = '0' + (in % 10);
    in /= 10;
  } while (r++, in != 0);
  return r;
}
*/

/* todo: Try making it auto variable */
static int sys_result;

/* Dynamic relocations used to bridge to libpulsedsp.so */
extern int (*dynopen)(const char *filename, int flags, ...);

/* todo: Shorten the executable name */
static char const *const exe = EXELTR;
#define NULLSTR &(exe[LENGTHOF(EXELTR) - 1])
static char const *const wrapping_args[8] = {
    NULLSTR, "xterm", "-ti", "vt340", "-geometry", "125x40", exe, NULLPTR};

/* todo: Prelude could be 'unmapped' and reused as .data after it is executed,
 * assuming no reentry */
__attribute((naked)) void entry(void) {
  int dsp_fd;

  /* Assume that if no open is relocated it's the initial execution */
  if (!dynopen) {
    char const **envp;
    asm volatile("movq $8, %%rax\n\t"
                 "mulq (%%rsp)\n\t"
                 "addq %%rsp, %%rax\n\t"
                 "addq $16, %%rax\n\t"
                 : "=a"(envp));
    SYS_EXECVE("/usr/bin/padsp", wrapping_args, envp);
    ASSERT(0);
  }

  ASSERT((dsp_fd = dynopen("/dev/dsp", O_WRONLY)) >= 0);

  while (1) {
    int i;
    SYS_WRITE(dsp_fd, "\x10\x00", 2);
    SYS_WRITE_LITERAL(FD_STDOUT, ASCII_ESCAPE "[0;0H" SIXEL_MODE_START);
    for (i = 0; i < 83; ++i)
      SYS_WRITE_LITERAL(FD_STDOUT, "!750~-");
    SYS_WRITE_LITERAL(FD_STDOUT, "!750~-" SIXEL_MODE_END);
  }

  SYS_EXIT(0);
  __builtin_unreachable();
}

#endif /* #ifdef BARE_BONES */
